"""
Base Strategy Interface

Defines the contract that all trading strategies must implement.
This is the foundation for the Transmission Plugin SDK.

All strategies inherit from BaseStrategy and implement:
- generate_signal() - Main signal generation logic
- required_regime - Which regime this strategy works in
- strategy_name - Human-readable name
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Optional, Literal, List
from datetime import datetime
from transmission.telemetry.market_data import MarketFeatures


@dataclass
class Position:
    """Represents an open position"""
    symbol: str
    direction: Literal['LONG', 'SHORT']
    entry_price: float
    contracts: int
    stop_price: float
    target_price: float
    entry_time: datetime


@dataclass
class Signal:
    """
    Trading signal generated by a strategy.

    This is the output of strategy.generate_signal() and the input
    to the execution engine.
    """
    symbol: str  # Trading symbol (e.g., "MNQ", "ES")
    entry_price: float
    stop_price: float
    target_price: float
    direction: Literal['LONG', 'SHORT']
    contracts: int
    confidence: float  # 0.0 to 1.0
    regime: str  # Regime when signal was generated
    strategy: str  # Strategy name
    timestamp: datetime
    notes: Optional[str] = None


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.
    
    All strategies must inherit from this class and implement:
    - generate_signal() - Main signal generation
    - required_regime property - Which regime this strategy works in
    - strategy_name property - Human-readable name
    """
    
    @abstractmethod
    def generate_signal(
        self,
        features: MarketFeatures,
        regime: str,
        current_positions: List[Position],
        symbol: str = "MNQ"
    ) -> Optional[Signal]:
        """
        Generate trading signal based on market conditions.

        Args:
            features: MarketFeatures with all calculated indicators
            regime: Current market regime ('TREND', 'RANGE', 'VOLATILE', 'NOTRADE')
            current_positions: List of currently open positions
            symbol: Trading symbol (default: "MNQ" for backward compatibility)

        Returns:
            Signal if setup found, None otherwise

        Note:
            - Should return None if regime doesn't match required_regime
            - Should return None if no valid setup exists
            - Should never raise exceptions for normal operation
        """
        pass
    
    @property
    @abstractmethod
    def required_regime(self) -> str:
        """
        Regime this strategy works in.
        
        Returns:
            'TREND', 'RANGE', or 'VOLATILE'
        """
        pass
    
    @property
    @abstractmethod
    def strategy_name(self) -> str:
        """
        Human-readable strategy name.
        
        Returns:
            Strategy name (e.g., 'VWAP Pullback', 'ORB Retest')
        """
        pass
    
    def validate_regime(self, regime: str) -> bool:
        """
        Check if current regime matches strategy requirements.
        
        Args:
            regime: Current market regime
            
        Returns:
            True if regime matches, False otherwise
        """
        return regime.upper() == self.required_regime.upper()
    
    def calculate_risk_reward_ratio(
        self,
        entry: float,
        stop: float,
        target: float,
        direction: Literal['LONG', 'SHORT']
    ) -> float:
        """
        Calculate risk:reward ratio for a signal.
        
        Args:
            entry: Entry price
            stop: Stop loss price
            target: Take profit price
            direction: 'LONG' or 'SHORT'
            
        Returns:
            Risk:reward ratio (e.g., 1:2 = 2.0)
        """
        if direction == 'LONG':
            risk = entry - stop
            reward = target - entry
        else:  # SHORT
            risk = stop - entry
            reward = entry - target
        
        if risk <= 0:
            return 0.0
        
        return reward / risk
    
    def calculate_confidence(
        self,
        features: MarketFeatures,
        setup_quality: float
    ) -> float:
        """
        Calculate signal confidence score.
        
        Args:
            features: MarketFeatures
            setup_quality: Quality score from strategy logic (0.0 to 1.0)
            
        Returns:
            Confidence score (0.0 to 1.0)
        """
        # Base confidence from setup quality
        confidence = setup_quality
        
        # Adjust for regime strength
        if features.adx_14 > 30:
            confidence *= 1.1  # Strong trend
        elif features.adx_14 < 15:
            confidence *= 0.9  # Weak trend
        
        # Adjust for liquidity
        if features.spread_ticks > 1.5:
            confidence *= 0.8  # Wide spread
        
        # Adjust for volume
        if features.rel_volume_hour < 0.7:
            confidence *= 0.9  # Low volume
        
        return min(1.0, max(0.0, confidence))  # Clamp to [0, 1]

