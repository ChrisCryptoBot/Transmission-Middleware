Task: Implement Multi-Asset Instrument Configuration System
Context: Lead engineer (Claude) has confirmed the architecture is 95% ready for multi-asset support. The adaptive "transmission" mechanisms (regime classification, ATR normalization, mental state adjustments, risk scaling) are 100% working. However, we have hardcoded MNQ-specific values that need to be made dynamic.

Priority: Complete this before building the manual trading UI. Estimated time: 6-8 hours.

Implementation Tasks
1. Create Instrument Specification Service (2-3 hours)
File: transmission/config/instrument_specs.py (NEW FILE)

"""
Instrument Specifications Service

Loads and provides instrument metadata from instruments.yaml.
Supports futures, equities, crypto, forex with symbol-specific specs.
"""

from typing import Dict, Optional
from pathlib import Path
import yaml
from loguru import logger
from dataclasses import dataclass


@dataclass
class InstrumentSpec:
    """Specification for a trading instrument"""
    symbol: str
    name: str
    exchange: str
    asset_class: str  # "futures", "equity", "crypto", "forex"
    point_value: float  # Dollar value per full point
    tick_size: float  # Minimum price increment
    tick_value: float  # Dollar value per tick
    margin_day: Optional[float] = None
    margin_overnight: Optional[float] = None
    trading_hours: Optional[str] = None
    session_start: Optional[str] = None
    session_end: Optional[str] = None
    timezone: Optional[str] = None


class InstrumentSpecService:
    """
    Service for loading and accessing instrument specifications.
    
    Usage:
        spec_service = InstrumentSpecService()
        mnq_spec = spec_service.get_spec("MNQ")
        point_value = mnq_spec.point_value  # 2.0
        tick_size = mnq_spec.tick_size  # 0.25
    """
    
    def __init__(self, config_path: Optional[str] = None):
        """
        Initialize Instrument Spec Service.
        
        Args:
            config_path: Path to instruments.yaml (default: config/instruments.yaml)
        """
        if config_path is None:
            config_path = Path(__file__).parent / "instruments.yaml"
        
        self.config_path = Path(config_path)
        self.instruments: Dict[str, InstrumentSpec] = {}
        self._load_instruments()
    
    def _load_instruments(self) -> None:
        """Load instrument specifications from YAML"""
        try:
            with open(self.config_path, 'r') as f:
                config = yaml.safe_load(f)
            
            if not config or 'instruments' not in config:
                logger.warning("No instruments found in config")
                return
            
            for symbol, spec_dict in config['instruments'].items():
                # Infer asset_class if not specified
                asset_class = spec_dict.get('asset_class', self._infer_asset_class(symbol))
                
                self.instruments[symbol] = InstrumentSpec(
                    symbol=symbol,
                    name=spec_dict.get('name', symbol),
                    exchange=spec_dict.get('exchange', 'UNKNOWN'),
                    asset_class=asset_class,
                    point_value=spec_dict['point_value'],
                    tick_size=spec_dict['tick_size'],
                    tick_value=spec_dict['tick_value'],
                    margin_day=spec_dict.get('margin_day'),
                    margin_overnight=spec_dict.get('margin_overnight'),
                    trading_hours=spec_dict.get('trading_hours'),
                    session_start=spec_dict.get('session_start'),
                    session_end=spec_dict.get('session_end'),
                    timezone=spec_dict.get('timezone')
                )
            
            logger.info(f"Loaded {len(self.instruments)} instrument specifications")
        
        except Exception as e:
            logger.error(f"Failed to load instruments config: {e}")
            raise
    
    def _infer_asset_class(self, symbol: str) -> str:
        """Infer asset class from symbol if not specified"""
        # Futures patterns
        if symbol in ['MNQ', 'MES', 'ES', 'NQ', 'YM', 'RTY', 'CL', 'GC', 'SI']:
            return 'futures'
        # Crypto patterns
        if 'BTC' in symbol or 'ETH' in symbol or 'USD' in symbol:
            return 'crypto'
        # Forex patterns
        if len(symbol) == 6 and any(curr in symbol for curr in ['USD', 'EUR', 'GBP', 'JPY']):
            return 'forex'
        # Default to equity
        return 'equity'
    
    def get_spec(self, symbol: str) -> InstrumentSpec:
        """
        Get instrument specification.
        
        Args:
            symbol: Instrument symbol (e.g., "MNQ")
        
        Returns:
            InstrumentSpec for the symbol
        
        Raises:
            ValueError: If symbol not found
        """
        if symbol not in self.instruments:
            raise ValueError(f"Instrument '{symbol}' not found in configuration")
        return self.instruments[symbol]
    
    def get_tick_size(self, symbol: str) -> float:
        """Get tick size for symbol"""
        return self.get_spec(symbol).tick_size
    
    def get_point_value(self, symbol: str) -> float:
        """Get point value for symbol"""
        return self.get_spec(symbol).point_value
    
    def get_tick_value(self, symbol: str) -> float:
        """Get tick value for symbol"""
        return self.get_spec(symbol).tick_value
    
    def get_asset_class(self, symbol: str) -> str:
        """Get asset class for symbol"""
        return self.get_spec(symbol).asset_class
    
    def list_symbols(self) -> list[str]:
        """List all available symbols"""
        return list(self.instruments.keys())
2. Update instruments.yaml (30 minutes)
File: transmission/config/instruments.yaml

Add these instruments (uncomment the MES section and add more):

# Transmission™ - Instrument Configuration
# Defines trading instruments and their properties

instruments:
  MNQ:
    name: "Micro E-mini Nasdaq-100"
    symbol: "MNQ"
    exchange: "CME"
    asset_class: "futures"
    point_value: 2.0  # $2 per point
    tick_size: 0.25   # Minimum price movement
    tick_value: 0.50  # $0.50 per tick
    margin_day: 1200  # Day trading margin (approximate)
    margin_overnight: 2400  # Overnight margin (approximate)
    trading_hours: "17:00-16:00 CT"  # Sunday-Friday
    session_start: "08:30 CT"  # Regular trading session
    session_end: "15:00 CT"
    timezone: "America/Chicago"
    
  MES:
    name: "Micro E-mini S&P 500"
    symbol: "MES"
    exchange: "CME"
    asset_class: "futures"
    point_value: 5.0
    tick_size: 0.25
    tick_value: 1.25
    margin_day: 1200
    margin_overnight: 2400
    trading_hours: "17:00-16:00 CT"
    session_start: "08:30 CT"
    session_end: "15:00 CT"
    timezone: "America/Chicago"
  
  ES:
    name: "E-mini S&P 500"
    symbol: "ES"
    exchange: "CME"
    asset_class: "futures"
    point_value: 50.0
    tick_size: 0.25
    tick_value: 12.50
    margin_day: 12000
    margin_overnight: 24000
    trading_hours: "17:00-16:00 CT"
    session_start: "08:30 CT"
    session_end: "15:00 CT"
    timezone: "America/Chicago"
  
  NQ:
    name: "E-mini Nasdaq-100"
    symbol: "NQ"
    exchange: "CME"
    asset_class: "futures"
    point_value: 20.0
    tick_size: 0.25
    tick_value: 5.00
    margin_day: 18000
    margin_overnight: 36000
    trading_hours: "17:00-16:00 CT"
    session_start: "08:30 CT"
    session_end: "15:00 CT"
    timezone: "America/Chicago"
3. Update PositionSizer (1 hour)
File: transmission/risk/position_sizer.py

Changes needed:

Add InstrumentSpecService to __init__:
from transmission.config.instrument_specs import InstrumentSpecService

class PositionSizer:
    def __init__(
        self,
        instrument_spec_service: Optional[InstrumentSpecService] = None,
        min_contracts: int = 1,
        max_risk_pct: float = 0.02,
        dll_risk_pct: float = 0.10
    ):
        # Remove hardcoded point_value parameter
        self.instrument_spec = instrument_spec_service or InstrumentSpecService()
        self.min_contracts = min_contracts
        self.max_risk_pct = max_risk_pct
        self.dll_risk_pct = dll_risk_pct
Update calculate_contracts() to accept symbol and look up point_value dynamically:
def calculate_contracts(
    self,
    symbol: str,  # ADD THIS PARAMETER
    risk_dollars: float,
    stop_points: float,
    atr_current: float,
    atr_baseline: float,
    dll_constraint: Optional[float] = None,
    mental_state: int = 5,
    account_balance: Optional[float] = None
) -> int:
    # Get instrument-specific point value
    point_value = self.instrument_spec.get_point_value(symbol)
    
    # Rest of logic stays the same, but use dynamic point_value
    # instead of self.point_value
Update line ~110 and anywhere else self.point_value is used:
# OLD:
risk_per_contract = stop_points * self.point_value

# NEW:
risk_per_contract = stop_points * point_value
4. Update Orchestrator (1 hour)
File: transmission/orchestrator/transmission.py

Changes needed:

Add InstrumentSpecService to __init__:
from transmission.config.instrument_specs import InstrumentSpecService

class TransmissionOrchestrator:
    def __init__(
        self,
        db_path: Optional[str] = None,
        config_path: Optional[str] = None,
        instrument_spec_service: Optional[InstrumentSpecService] = None
    ):
        # ... existing init code ...
        
        # Add instrument spec service
        self.instrument_spec = instrument_spec_service or InstrumentSpecService()
        
        # Pass to PositionSizer
        self.position_sizer = PositionSizer(
            instrument_spec_service=self.instrument_spec
        )
Fix hardcoded tick_size on line 458 in process_signal():
# OLD (line 458):
spread_ticks = (ask - bid) / 0.25  # Assuming tick size = 0.25  ❌

# NEW:
tick_size = self.instrument_spec.get_tick_size(signal.symbol)
spread_ticks = (ask - bid) / tick_size  ✅
Update all position_sizer.calculate_contracts() calls to pass symbol:
# Find all calls like this:
contracts = self.position_sizer.calculate_contracts(
    risk_dollars=risk_dollars,
    # ... other params
)

# Update to:
contracts = self.position_sizer.calculate_contracts(
    symbol=signal.symbol,  # ADD THIS
    risk_dollars=risk_dollars,
    # ... other params
)
5. Add asset_class to Signal (30 minutes)
File: transmission/strategies/base.py

Update the Signal dataclass:

@dataclass
class Signal:
    """
    Trading signal generated by a strategy.

    This is the output of strategy.generate_signal() and the input
    to the execution engine.
    """
    symbol: str  # Trading symbol (e.g., "MNQ", "ES")
    asset_class: str  # Asset class: "futures", "equity", "crypto", "forex"  # NEW
    entry_price: float
    stop_price: float
    target_price: float
    direction: Literal['LONG', 'SHORT']
    contracts: int
    confidence: float  # 0.0 to 1.0
    regime: str  # Regime when signal was generated
    strategy: str  # Strategy name
    timestamp: datetime
    notes: Optional[str] = None
6. Update Signal Adapters (1 hour)
File: transmission/strategies/signal_adapter.py

Update all three adapters to include asset_class:

# In TradingViewAdapter.parse():
return Signal(
    symbol=symbol,
    asset_class="futures",  # ADD THIS - infer from symbol or alert payload
    entry_price=entry_price,
    # ... rest of fields
)

# In MT5Adapter.parse():
return Signal(
    symbol=symbol,
    asset_class="futures",  # ADD THIS
    entry_price=entry_price,
    # ... rest of fields
)

# In GenericWebhookAdapter.parse():
asset_class = raw_signal.get('asset_class', 'futures')  # Allow override
return Signal(
    symbol=symbol,
    asset_class=asset_class,  # ADD THIS
    entry_price=entry_price,
    # ... rest of fields
)
Better yet, make it smart:

# Add helper method to SignalAdapter base class:
def infer_asset_class(self, symbol: str) -> str:
    """Infer asset class from symbol"""
    try:
        from transmission.config.instrument_specs import InstrumentSpecService
        spec_service = InstrumentSpecService()
        return spec_service.get_asset_class(symbol)
    except:
        # Fallback inference
        if symbol in ['MNQ', 'MES', 'ES', 'NQ']:
            return 'futures'
        return 'unknown'

# Then use in parse():
asset_class = self.infer_asset_class(symbol)
7. Update VWAPPullbackStrategy (15 minutes)
File: transmission/strategies/vwap_pullback.py

Update both _check_long_entry() and _check_short_entry():

# In both methods, update Signal creation:
return Signal(
    symbol=symbol,
    asset_class="futures",  # ADD THIS - or make it dynamic
    entry_price=entry_price,
    stop_price=stop_price,
    target_price=target_price,
    # ... rest of fields
)
Or better, infer it:

# Add at top of file:
from transmission.config.instrument_specs import InstrumentSpecService

# In __init__:
def __init__(self, ...):
    self.instrument_spec = InstrumentSpecService()
    # ... rest

# In Signal creation:
asset_class = self.instrument_spec.get_asset_class(symbol)
return Signal(
    symbol=symbol,
    asset_class=asset_class,
    # ...
)
8. Write Tests (1-2 hours)
File: tests/test_instrument_specs.py (NEW FILE)

"""
Tests for Instrument Specification Service
"""

import pytest
from transmission.config.instrument_specs import InstrumentSpecService, InstrumentSpec


def test_load_instruments():
    """Test loading instruments from YAML"""
    service = InstrumentSpecService()
    
    assert len(service.list_symbols()) >= 1
    assert 'MNQ' in service.list_symbols()


def test_get_spec():
    """Test getting instrument spec"""
    service = InstrumentSpecService()
    
    mnq_spec = service.get_spec('MNQ')
    assert mnq_spec.symbol == 'MNQ'
    assert mnq_spec.point_value == 2.0
    assert mnq_spec.tick_size == 0.25
    assert mnq_spec.tick_value == 0.50
    assert mnq_spec.asset_class == 'futures'


def test_get_helpers():
    """Test helper methods"""
    service = InstrumentSpecService()
    
    assert service.get_tick_size('MNQ') == 0.25
    assert service.get_point_value('MNQ') == 2.0
    assert service.get_tick_value('MNQ') == 0.50
    assert service.get_asset_class('MNQ') == 'futures'


def test_multiple_instruments():
    """Test loading multiple instruments"""
    service = InstrumentSpecService()
    
    # Test MNQ
    mnq = service.get_spec('MNQ')
    assert mnq.point_value == 2.0
    
    # Test MES (if added)
    if 'MES' in service.list_symbols():
        mes = service.get_spec('MES')
        assert mes.point_value == 5.0
        assert mes.tick_value == 1.25


def test_invalid_symbol():
    """Test error handling for invalid symbol"""
    service = InstrumentSpecService()
    
    with pytest.raises(ValueError, match="not found"):
        service.get_spec('INVALID')
Testing Checklist
After implementing:

Run tests:

pytest tests/test_instrument_specs.py -v
Test with MNQ (should work exactly as before):

python startup/run_api.py
# Send webhook with MNQ symbol
Test with MES (if added):

# Send webhook with MES symbol
# Verify position sizing uses 5.0 point value instead of 2.0
Verify no hardcoded values remain:

grep -r "point_value: float = 2.0" transmission/
grep -r "/ 0.25  #" transmission/
# Should find zero hardcoded references
Commit Strategy
Make separate commits for each component:

feat: Add InstrumentSpecService for multi-asset support
feat: Update instruments.yaml with MES, ES, NQ specs
refactor: Remove hardcoded point_value from PositionSizer
refactor: Remove hardcoded tick_size from Orchestrator
feat: Add asset_class field to Signal dataclass
refactor: Update signal adapters with asset_class inference
test: Add InstrumentSpec service tests
Success Criteria
✅ No hardcoded point_value = 2.0 anywhere
✅ No hardcoded / 0.25 for tick_size
✅ InstrumentSpecService loads from YAML
✅ All tests pass
✅ Webhooks work for both MNQ and MES (if added)
✅ Position sizing adapts to different point values
✅ Signal includes asset_class field

Priority: HIGH - Complete before building manual UI
Assignee: Cursor AI (local development)
Lead Engineer: Claude (code review & architecture)

Push to branch claude/product-architecture-decision-011CV58jrgPtwAZ9gB2LSbex when complete.